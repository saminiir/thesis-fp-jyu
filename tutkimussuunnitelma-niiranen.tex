% !TeX encoding = latin1
%
% [ Tiedostossa käytetty merkistö on ISO 8859-1 eli Latin 1. Ylläoleva rivi ]
% [ tarvitaan, jos käyttää MiKTeX-paketin mukana tulevaa TeXworks-editoria. ]
%
% TIETOTEKNIIKAN KANDIDAATINTUTKIELMA
%
% Yksinkertainen LaTeX2e-mallipohja kandidaatintutkielmalle.
% Käyttää Antti-Juhani Kaijanahon ja Matthieu Weberin kirjoittamaa
% gradu2-dokumenttiluokkaa.
%
% Laatinut Timo Männikkö
%
% Jos kirjoitat pro gradu -tutkielmaa, tee mallipohjaan seuraavat muutokset:
%  - Poista dokumenttiluokasta optio shortthesis .
%  - Poista makro \tyyppi .
%  - Lisää suuntautumisvaihtoehto makrolla \linja .
%  - Kirjoita ylimmän tason otsikot makrolla \chapter, toisen tason otsikot
%    makrolla \section ja mahdolliset kolmannen tason otsikot makrolla
%    \subsection .
%
% Halutessasi voit tehdä myös kandidaatintutkielman "pro gradu -tyylillä":
%  - Poista shortthesis-optio.
%  - Kirjoita otsikot makroilla \chapter , \section (ja \subsection ).

\documentclass[english]{tjt-latex-gradupohja/gradu3}

\usepackage{graphicx} % tarvitaan vain, jos halutaan mukaan kuvia

\usepackage{booktabs} % hyvä kauniiden taulukoiden tekemiseen

\usepackage{babel}

\usepackage{comment}

\usepackage[bookmarksopen,bookmarksnumbered,linktocpage]{hyperref}

\tolerance=2000 \emergencystretch=10pt % Better hyphenation without overflowing lines

\addbibresource{sources-niiranen.bib}

\begin{document}

\title{Functional reactive programming and software quality}
\translatedtitle{Reaktiivinen funktionaalinen ohjelmointi}

\author{Sami Niiranen}
\contactinformation{sami.i.niiranen@student.jyu.fi}

\supervisor{Jukka Lindström}

\setdate{27}{02}{2014}

\abstract{Research plan for the thesis.}
\tiivistelma{Pro Gradu -tutkielman tutkimussuunnitelma.}

\avainsanat{tietojärjestelmätiede, pro gradu -tutkielma, tutkimussuunnitelma}    % korvaa nämä oikeilla
\keywords{information technology, Master's thesis, research plan} % avainsanoilla

%\studyline{Järjestelmäkehitys}

\maketitle

\mainmatter

\chapter{Background of the research}

As information systems, architectures and graphical user interfaces grow ever more complex, the focus on delivering maintainable and scalable software is of great importance. Recently,~\citet{reactive2013} was signed by over four thousand enthusiasts. The main inspiration of the manifesto is functional reactive programming (FRP)~\parencite{elliott1997functional}, which aims to solve many of the concurrency and coupling problems of traditional software approaches by introducing higher-level abstraction to code design than what procedural approaches offer. More specifically, FRP introduces event-handling mechanisms that hide away the implementation, leaving only concise abstractions in the codebase~\parencite{czaplicki2012elm}. 

Functional programming is a software language paradigm, where functions are first-class ``citizens'' and ``pure''. State, as often manifesting as variables in imperative languages, is avoided and captured into structures such as~\textit{monads}.  Functional reactive programming adds to the functional paradigm by shifting the focus on time-varying~\textit{behaviors} and streams of~\textit{events}~\parencite{wan2000functional}. These concepts are used for hiding implementation details and providing a high-level abstraction for development. Essentially, FRP is a declarative programming model for creating interactive applications.
%{{{
\begin{comment}
The key ideas in FRP are its notions of behaviors and events. Behaviors are time-varying, reactive values, while events are time-ordered sequences of discrete-time event occurrences.

Functional Reactive Programming (FRP) is a high-level declara- tive programming model for constructing interactive applications.~\parencite{courtney2001frappe}.
\end{comment}
%}}}

\section{Motivation}

Even though FRP is not a new programming paradigm~\parencite{elliott1997functional}, it has eluded wide adoption. Recently, however, more software practitioners~\parencite{netflix2013,futurice2014,flowdock2013} have started to implement both systems as well as graphical user interfaces in the spirit of FRP. Unlike software quality assessment on imperative and object-oriented languages, similar comparison on functional languages is scarce~\parencite{harrison1995estimating,harrison1996comparing} and almost non-existant on the FRP paradigm. However, as the FRP paradigm gains popularity, also the software quality metrics should be updated to support the high-level abstractions of the approach.

\section{Previous work}

Functional reactive programming has its root in academia~\parencite{elliott1997functional}, and as such, has been moderately researched~\parencite{elliott1997functional,elliott2009push,wan2000functional,wan2002event,sculthorpe2011towards,nilsson2002functional}. As the adaptation of FRP in popular use is still in progress, most of the research has concentrated on the semantics of FRP.

Code analysis and comparison of quality in functional programming paradigms is relatively scarce~\parencite{hudak1994haskell,harrison1996comparing,harrison1995estimating,harrison1996evaluation}. Studies of applying FRP in imperative languages is scarce~\parencite{courtney2001frappe}. Moreover, not a single study researching the software quality metrics on FRP was found.

\chapter{Research problem and methods}
The aim of the study is to present the functional reactive programming paradigm, its main concepts and how it is efficiently utilized. Challenges of the paradigm and its use in practical settings are analyzed.

\section{Limitations}
While implementing a pure approach to functional reactive programming is troublesome (due to several limitations, such as computer's capability of modelling time), several ``compromises'' of FRP exist. As they are numerous and applied to different settings, only thorough examination of one of these implementations is feasible.

\section{Research problem}
The research can be decomposed into four questions:

\begin{itemize}
    \item What is functional reactive programming and its concepts?
    \item What are the challenges of FRP and how can it be utilized in practical settings?
    \item How do the software quality metrics apply to FRP code bases?
\end{itemize}

\noindent The research problem can be expressed as follows: \textit{What is functional reactive programming and how do software quality metrics apply to its implementations?}

\section{Research methods}
The thesis utilizes literature review as its main research method. The review consists of an overview into functional and reactive programming and the metrics of software quality. 

In the second part, the research themes are investigated through empirical research. This consists of developing an application adhering to the FRP principles. Some research ideas are as follows: 

\begin{itemize}
    \item Compare and analyze the code quality of two versions of an application implemented with FRP and imperative programming paradigms
    \item Develop an application for creating marble diagrams out of FRP abstractions in the given source code
\end{itemize}

\section{Expected results and their significance}
The results aim at explaining the various semantics of FRP and how they relate to software quality. As FRP is especially tailored for data-driven designs, the results are expected to be positive in such settings. However, analyzing software implemented with FRP might differ from traditional software quality metrics.

The research is expected to be of significance to researchers and practitioners alike. The results will help in formulating the concepts of FRP into practical settings and pinpoint the challenges of the approach. Future research will be fueled by providing more support to the functional and reactive paradigms as opposed to imperative approaches.

\chapter{Preliminary content}
This chapter describes the preliminary structure of the study.

\section{Introduction}
Introduction will guide the reader into the subject by outlining the topic, motivating the study and defining the basic concepts. The chapter also specifies the research problem and questions, as well as describe the research methods and the structure of the contents.

Introduction will be around 3-4 pages.
\section{Functional programming}

This chapter will provide an overview into the functional programming paradigm.
Length is expected to be around 10 pages.

\subsection{Motivation of functional languages}

\subsection{Concepts}

\subsection{Summary}

\begin{itemize}
    \item Imperative functional programming~\parencite{peyton1993imperative}
    \item Comparing programming paradigms: an evaluation of functional and object-oriented programs~\parencite{harrison1996comparing}
\end{itemize}
\section{Reactive programming}

This chapter will provide an overview into the reactive programming paradigm in the context of functional programming.
Length is expected to be around 15 pages.

\begin{itemize}
    \item Deprecating the observer pattern~\parencite{maier2010deprecating}
    \item Design patterns: elements of reusable object-oriented software~\parencite{gamma1994design}
    \item A Possible Future of Software Development~\parencite{parent2006adobe}
\end{itemize}

\subsection{Concepts}

\begin{itemize}
    \item Signals
    \item Structural dynamism
    \item Constant behaviours
    \item Time-varying behaviours
    \item Events
    \item Combinators
\end{itemize}
%{{{
\begin{comment}
The simplest examples of behaviors are constant behaviors: those that ignore their time argument and evaluate to some constant value.~\parencite{courtney2001frappe}.

An example of a time-varying behavior (taken from a binding of FRP for computer animation [5]) is mouse (of type Behavior Point).~\parencite{courtney2001frappe}

Conceptually, an Event is some condition that occurs at a discrete point in time.~\parencite{courtney2001frappe}.
\end{comment}
%}}}
\subsection{Challenges of FRP}

\begin{itemize}
    \item Time- and space-leaks
    \item Instantaneous predicate events
\end{itemize}
%{{{
\begin{comment}
An efficient, robust implementation of the FRP model that is both faithful to the formal se- mantics and does not suffer from space leaks or other performance problems has remained an elusive goal, and we do not expect that this situation will change in the near future.~\parencite{courtney2001frappe}.

Like the stream-based implementation from which it derives, our implementation of FRP is unable to detect instantaneous pred- icate events.~\parencite{courtney2001frappe}.
\end{comment}
%}}}

\subsection{Implementations of FRP}
\begin{itemize}
    \item Stream-based FRP
    \item FrTime, Scheme (Integrating dataflow evaluation into a practical higher-order call-by-value language~\parencite{cooper2008integrating})
    \item Elm (Elm: Concurrent FRP for Functional GUIs~\parencite{czaplicki2012elm})
    \item Scala.React (Deprecating the observer pattern~\parencite{maier2010deprecating})
    \item Fran (Functional reactive animation~\parencite{elliott1997functional}, Push-pull functional reactive programming~\parencite{elliott2009push} )
    \item Yampa (The yampa arcade~\parencite{courtney2003yampa})
    \item Flapjax (Flapjax: a programming language for Ajax applications~\parencite{meyerovich2009flapjax})
    \item Frappe (Frapp{\'e}: Functional reactive programming in Java~\parencite{courtney2001frappe})
\end{itemize}

%{{{
\begin{comment}
One recent implementation of FRP that has received particular scrutiny is the so-called stream-based implementation, described in [9].4 A related paper [18] analyzes this implementation formally, showing that, with one caveat5, as the sample time approaches 0, the implementation is faithful to the formal semantics.~\parencite{courtney2001frappe}.
\end{comment}
%}}}

%}}}
\subsection{Summary}

\begin{itemize}
    \item Towards safe and efficient functional reactive programming~\parencite{sculthorpe2011towards}
    \item Functional reactive programming from first principles~\parencite{wan2000functional}
\end{itemize}

\section{Software quality}

This chapter will provide an overview into software quality and the metrics of code quality analysis.
Length is expected to be around 15 pages.

\begin{itemize}
    \item Quantitative evaluation of software quality~\parencite{boehm1976quantitative}
    \item Standardized code quality benchmarking for improving software maintainability~\parencite{baggen2012standardized}
\end{itemize}

\subsection{Metrics}
\subsection{Summary}

\section{Empirical study}

The thesis contains an empirical study in the form of application development. The construction of the application is based on the concepts of the literature review part of the thesis.

The chapter will be 10-15 pages.

\section{Discussion}

This chapter compares the results of the empirical research to scientific studies, and analyzes the accuracy and reliability of the findings. Also the usefulness of the results will be discussed.

The chapter will be 4-6 pages.

\section{Summary and conclusions}

The summary will conclude the study and sum up the research and its conclusions. 

The chapter will be around 3 pages in length. In total the page count of the content averages between 60 and 80 pages. 

\chapter{Schedule}
Schedule: \\
\\
\begin{tabular}{| l | r |}
    \hline
    Reseach plan & February 2014 \\
    Mini-thesis (chapters 1 to 3) & March 2014 \\
    Empirical research & April 2014 \\
    Research results \& analysis & May 2014 \\
    Polishing \& conclusion & June 2014 \\
    \hline
\end{tabular}

\noindent The thesis is set to be finished in June 2014. 

\printbibliography

\end{document}
