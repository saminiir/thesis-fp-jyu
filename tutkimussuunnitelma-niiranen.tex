% !TeX encoding = latin1
%
% [ Tiedostossa käytetty merkistö on ISO 8859-1 eli Latin 1. Ylläoleva rivi ]
% [ tarvitaan, jos käyttää MiKTeX-paketin mukana tulevaa TeXworks-editoria. ]
%
% TIETOTEKNIIKAN KANDIDAATINTUTKIELMA
%
% Yksinkertainen LaTeX2e-mallipohja kandidaatintutkielmalle.
% Käyttää Antti-Juhani Kaijanahon ja Matthieu Weberin kirjoittamaa
% gradu2-dokumenttiluokkaa.
%
% Laatinut Timo Männikkö
%
% Jos kirjoitat pro gradu -tutkielmaa, tee mallipohjaan seuraavat muutokset:
%  - Poista dokumenttiluokasta optio shortthesis .
%  - Poista makro \tyyppi .
%  - Lisää suuntautumisvaihtoehto makrolla \linja .
%  - Kirjoita ylimmän tason otsikot makrolla \chapter, toisen tason otsikot
%    makrolla \section ja mahdolliset kolmannen tason otsikot makrolla
%    \subsection .
%
% Halutessasi voit tehdä myös kandidaatintutkielman "pro gradu -tyylillä":
%  - Poista shortthesis-optio.
%  - Kirjoita otsikot makroilla \chapter , \section (ja \subsection ).

\documentclass[english]{tjt-latex-gradupohja/gradu3}

\usepackage{graphicx} % tarvitaan vain, jos halutaan mukaan kuvia

\usepackage{booktabs} % hyvä kauniiden taulukoiden tekemiseen

\usepackage{babel}

\usepackage{comment}

\usepackage[bookmarksopen,bookmarksnumbered,linktocpage]{hyperref}

\tolerance=2000 \emergencystretch=10pt % Better hyphenation without overflowing lines

\addbibresource{sources-niiranen.bib}

\begin{document}

\title{Functional reactive programming and software quality}
\translatedtitle{Reaktiivinen funktionaalinen ohjelmointi}

\author{Sami Niiranen}
\contactinformation{sami.i.niiranen@student.jyu.fi}

\supervisor{Jukka Lindström}

\setdate{27}{02}{2014}

\abstract{Research plan for the thesis.}
\tiivistelma{Pro Gradu -tutkielman tutkimussuunnitelma.}

\avainsanat{tietojärjestelmätiede, pro gradu -tutkielma, tutkimussuunnitelma}    % korvaa nämä oikeilla
\keywords{information technology, Master's thesis, research plan} % avainsanoilla

%\studyline{Järjestelmäkehitys}

\maketitle

\mainmatter

\chapter{Background of the research}

As information systems, architectures and graphical user interfaces grow ever more complex, the focus on delivering maintainable and scalable software is of great importance. Recently, the Reactive Manifesto~\parencite{reactive2013} was signed by over four thousand enthusiasts. The main inspiration of the manifesto is functional reactive programming (FRP)~\parencite{reactive2013}, which aims to solve many of the concurrency and coupling problems of traditional approaches by introducing higher-level abstraction to code design than what procedural approaches, such as in C, can offer. More specifically, FRP introduces event-handling mechanisms that hide away the implementation, leaving only concise abstractions in the codebase~\parencite{czaplicki2012elm}. 

Even though FRP is not a new programming paradigm~\parencite{elliott1997functional}, it has eluded wide adoption. Recently, however, more software practitioners~\parencite{netflix2013,futurice2014,flowdock2013} have started to implement both systems as well as graphical user interfaces in the spirit of FRP.

time as a discrete variable to software design and to which components can be hooked and increasing number of of the manifesto are the requirements of complex and large-scale application domains, ranging from ``mobile devices to cloud-based clusters running thousands of multicore processors''~\parencite{reactive2013}. Functional reactive programming aims to deliver event-driven and resilient application stacks for computing environments where concurrency and scalability are central.~\parencite{reactive2013}

Essentially functional reactive programming (FRP) is a declarative programming model for creating interactive applications. Unlike in imperative languages, The FRP paradigm treats~\textit{time} as a continuous model and, in which the programmer attaches signals models time as continuous
%{{{
\begin{comment}
Functional Reactive Programming (FRP) is a high-level declara- tive programming model for constructing interactive applications.~\parencite{courtney2001frappe}.
\end{comment}
%}}}
Applications implemented with the FRP-paradigm are said to provide elegant solutions 

Not only in heavy server-side computing, but FRP is also increasingly utilized in ``smaller'' application domains such as RESTful services and mobile applications. The driving force behind FRP is to increase the abstraction level of programming, enabling developers to concentrate on the objectives rather than the implementation.

Since functional reactive programming is most often implemented as an embedded domain specific language, the details of the~\textit{host} language play an important part~\parencite{sculthorpe2011towards}.
%{{{
\begin{comment}
The functional level is a pure functional language. FRP implementations are usually embedded in a host language, and in these cases the functional level is provided entirely by the host.~\parencite{sculthorpe2011towards}.
\end{comment}
%}}}
Functional programming is a software language paradigm, where functions are first-class citizens and ``pure''. State, as often manifesting as variables in imperative languages, is avoided and captured into concepts such as~\textit{monads}.

Functional reactive programming adds to the functional paradigm by shifting the focus on time-varying~\textit{behaviors} and streams of~\textit{events}~\parencite{wan2000functional}. Essentially,
%{{{
\begin{comment}
The key ideas in FRP are its notions of behaviors and events. Behaviors are time-varying, reactive values, while events are time-ordered sequences of discrete-time event occurrences.
\end{comment}
%}}}

Research questions:
    -What is functional reactive programming and its advantages and challenges?
    -How is code quality (volume, redundancy, unit size, complexity, coupling) measured with FRP?
    -How is FRP implemented in imperative-style programming languages?
    -Are there practicalities when implementing applications in with FRP?
        -Is there a threat of ``time-space'' memory-leaks ?
        -How are FRP-style code bases tested?

\section{Motivation}

The current notion on software development is the need for developing scalable and fault-tolerant systems~\parencite{reactive2013}.

\section{Previous work}

Studies on applying FRP in imperative languages is scarce;~\parencite{courtney2001frappe}.

Code analysis and comparison on different program versions written with both functional and imperative paradigms is also scarce~\parencite{hudak1994haskell,harrison1996comparing}.

\chapter{Research problem and methods}
The aim of the study is to present the FRP paradigm, its main concepts and how it is efficiently utilized. Challenges of the paradigm are analyzed.
\section{Limitations}
The subject of teams and teamwork is a vast, multi-disciplinary research topic. This study will be limited to agile methods utilized in software development. Furthermore, the behaviour of individual team members and their collaboration is examined strictly from the viewpoint of agile software projects.
\section{Research problem}
The research can be decomposed into four questions:

\begin{itemize}
    \item What are the characteristics and guidelines of a self-organizing team?
    \item How is the performance of agile teams perceived and measured?
    \item What kind of impact self-organization is seen to have on performance?
    \item What kind of experiences from working in self-organized teams in actual projects have been gained?
\end{itemize}

The research problem can be expressed as follows: \textit{How does self-organization affect team performance in agile software development?}
\section{Research methods}
The thesis utilizes literature review as its main research method. The review consists of an overview into functional and reactive programming and the metrics of software quality. 

In the second part, the research themes are investigated through empirical research. This consists of developing an application adhering to the FRP principles. Some research ideas are as follows: Compare and analyze the code quality of an application implemented with FRP and imperative programming paradigms. Develop an aplication for creating marble diagrams out of FRP abstraction in source code.

\section{Expected results and their significance}
The results aim at explaining the various semantics of FRP and how they relate to software quality. As FRP is especially tailored for data-driven designs, the results are expected to be positive in such settings. However,   the nature of self-organization and effectiveness in agile teams. The expected results are that self-organization improves the performance of an agile team and that self-organization is actively being promoted in prominent software consultant companies. The results will consist of practical knowledge of how to promote team self-organization to achieve greater team effectiveness.

The empirical part aims to provide concrete means for approaching FRP: Either as code quality analysis or visualizing FRP graphs. Either way, the results should be of interest to academics and practitioners alike and should fuel future research.

\chapter{Preliminary content}
This chapter describes the preliminary structure of the study.

\section{Introduction}
Introduction will guide the reader into the subject by outlining the topic, motivating the study and defining the basic concepts. The chapter also specifies the research problem and questions, as well as describe the research methods and the structure of the contents.

Introduction will be around 3-4 pages.
\section{Functional programming}
\subsection{Motivation of functional languages}

\subsection{History}

\subsection{Summary}
Imperative functional programming~\parencite{peyton1993imperative}
Comparing programming paradigms: an evaluation of functional and object-oriented programs~\parencite{harrison1996comparing}
\section{Reactive programming}
\subsection{Signals}
\subsection{Structural dynamism}
\subsection{Behaviours and Events}

Constant behaviours
Time-varying behaviours
Events
%{{{
\begin{comment}
The simplest examples of behaviors are constant behaviors: those that ignore their time argument and evaluate to some constant value.~\parencite{courtney2001frappe}.

An example of a time-varying behavior (taken from a binding of FRP for computer animation [5]) is mouse (of type Behavior Point).~\parencite{courtney2001frappe}

Conceptually, an Event is some condition that occurs at a discrete point in time.~\parencite{courtney2001frappe}.
\end{comment}
%}}}
\subsection{Combinators}
\subsection{Implementations of FRP}
Stream-based FRP
%{{{
\begin{comment}
One recent implementation of FRP that has received particular scrutiny is the so-called stream-based implementation, described in [9].4 A related paper [18] analyzes this implementation formally, showing that, with one caveat5, as the sample time approaches 0, the implementation is faithful to the formal semantics.~\parencite{courtney2001frappe}.
\end{comment}
%}}}
\subsection{FRP as an Embedded Domain-Specific Language}
\subsection{Challenges of FRP}
Time- and space -leaks
%{{{
\begin{comment}
An efficient, robust implementation of the FRP model that is both faithful to the formal se- mantics and does not suffer from space leaks or other performance problems has remained an elusive goal, and we do not expect that this situation will change in the near future.~\parencite{courtney2001frappe}.
\end{comment}

Instantaneous predicate events
%{{{
\begin{comment}
Like the stream-based implementation from which it derives, our implementation of FRP is unable to detect instantaneous pred- icate events.~\parencite{courtney2001frappe}.
\end{comment}
%}}}

%}}}
\subsection{Summary}
Towards safe and efficient functional reactive programming~\parencite{sculthorpe2011towards}
Functional reactive programming from first principles~\parencite{wan2000functional}

\section{Software quality}
\subsection{Summary}

The chapter's length is expected to be around 15 pages.

Quantitative evaluation of software quality~\parencite{boehm1976quantitative}
Standardized code quality benchmarking for improving software maintainability~\parencite{baggen2012standardized}

\section{Empirical study}
\subsection{Objective-C and iOS}
\subsection{ReactiveCocoa}

The thesis aims to contain an empirical research of the subject. The research will be conducted either as a survey or as a interview -based questionnaire. The actual research model will be built based on the thesis's literature review. The findings will be reported from conclusions from the research and from the answers of the questionnaire. 

The chapter will be 10-15 pages.

\section{Discussion}

This chapter compares the results of the empirical research to scientific studies, and analyzes the accuracy and reliability of the findings. Also the usefulness of the results will be discussed.

The chapter will be 4-6 pages.

\section{Summary and conclusions}

The summary will conclude the study and sum up the research and its conclusions. 

The chapter will be around 3 pages in length.

In total the page count averages between 70 and 93 pages. 

\chapter{Schedule}
Schedule: \\
\\
\begin{tabular}{| l | r |}
    \hline
    Reseach plan & November 2013 \\
    Mini-thesis (chapters 1 to 3) & January 2014 \\
    Empirical research & March 2014 \\
    Research results \& analysis & April 2014 \\
    Polishing \& conclusion & May 2014 \\
    \hline
\end{tabular}

The thesis is set to be finished in May 2014. The empirical part should be started as soon as possible in the beginning of next year, to have enough time to collect and analyze the data.

\printbibliography

\end{document}
